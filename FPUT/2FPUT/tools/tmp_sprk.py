import numpy as np
import numba as nb

@nb.njit()
def Yo8_step(q, p, m, dt):
    q = q.copy()
    p = p.copy()

    def gradT(p, m):
        pass

    def gradV(q):
        pass

    C_COEFFS = np.array([0.521213104349955, 1.431316259203525, 0.988973118915378,
                         1.298883627145484, 1.216428715985135, -1.227080858951161,
                         -2.031407782603105, -1.698326184045211, -1.698326184045211,
                         -2.031407782603105, -1.227080858951161, 1.216428715985135,
                         1.298883627145484, 0.988973118915378, 1.431316259203525,
                         0.521213104349955])
    D_COEFFS = np.array([1.04242620869991, 1.82020630970714, 0.157739928123617,
                         2.44002732616735, -0.007169894197081, -2.44699182370524,
                         -1.61582374150097, -1.780828626589452, -1.61582374150097,
                         -2.44699182370524, -0.007169894197081, 2.44002732616735,
                         0.157739928123617, 1.82020630970714, 1.04242620869991])
    for i in range(15):
        p -= C_COEFFS[i] * gradV(q) * dt
        q += D_COEFFS[i] * gradT(p, m) * dt
    p -= C_COEFFS[15] * gradV(q) * dt
    return q, p

@nb.njit()
def SPRK8_step(q, p, m, dt):
    q = q.copy()
    p = p.copy()

    def gradT(p, m):
        pass

    def gradV(q):
        pass

    # 积分器常数
    C_COEFFS = np.array([
        0.195557812560339,
        0.433890397482848,
        -0.207886431443621,
        0.078438221400434,
        0.078438221400434,
        -0.207886431443621,
        0.433890397482848,
        0.195557812560339,
    ])
    D_COEFFS = np.array([
        0.0977789062801695,
        0.289196093121589,
        0.252813583900000,
        -0.139788583301759,
        -0.139788583301759,
        0.252813583900000,
        0.289196093121589,
        0.0977789062801695,
    ])

    for i in range(8):
        q += D_COEFFS[i] * gradT(p, m) * dt
        p -= C_COEFFS[i] * gradV(q) * dt
    return q, p
